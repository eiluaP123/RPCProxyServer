// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Something.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/select.h>
#include <curl/curl.h>
#include "cache.h"
#include <time.h>
#include <sys/time.h>

#define CACHE_FIX_SIZE 1024*1024

struct wd_in {
  size_t size;
  size_t len;
  char *data;
};

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using boost::shared_ptr;
using namespace  ::Test;
using namespace std;

double num_accesses;
double num_hits;
double hit_rate;

/* This function is registered as a callback with CURL.  As the data
   from the requested webpage is returned in chunks, write_data is
   called with each chunk.  */
  static size_t write_data(void *buffer, size_t size, 
                         size_t nmemb, void *userp) {
  struct wd_in *wdi = userp;

  while(wdi->len + (size * nmemb) >= wdi->size) {
    /* check for realloc failing in real code. */
    wdi->data = realloc(wdi->data, wdi->size*2);
    wdi->size*=2;
  }

  memcpy(wdi->data + wdi->len, buffer, size * nmemb);
  wdi->len+=size*nmemb;
  return size * nmemb;
}

class SomethingHandler : virtual public SomethingIf {
 public:
  SomethingHandler() {
  }

  void ping(std::string& _return, const std::string& url) {
  // Your implementation goes here
  std::string ret_val = search_page(url.c_str());
  CURL *curl;
  CURLcode res;
  struct wd_in wdi;
  //char *url = "http://www.google.com";

  memset(&wdi, 0, sizeof(wdi));
  printf("\nFetch the page\n");
  num_accesses++;

  if(ret_val.compare("NOT_FOUND")==0) {
    printf("\nPage not in Cache. Fetch from URL.\n");

   /* Get a curl handle.  Each thread will need a unique handle. */
    curl = curl_easy_init();

    if(NULL != curl) {
      wdi.size = 1024;
      /* Check for malloc failure in real code. */
      wdi.data = malloc(wdi.size);

      /* Set the URL for the operation. */
      curl_easy_setopt(curl, CURLOPT_URL, url.c_str());

      /* "write_data" function to call with returned data. */
      curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data);

      /* userp parameter passed to write_data. */
      curl_easy_setopt(curl, CURLOPT_WRITEDATA, &wdi);

      /* Actually perform the query. */
      res = curl_easy_perform(curl);

      /* Check the return value and do whatever. */
  
      /* Clean up after ourselves. */
      curl_easy_cleanup(curl);
    }
    else {
      fprintf(stderr, "Error: could not get CURL handle.\n");
      exit(EXIT_FAILURE);
    }

    /* Now wdi.data has the data from the GET and wdi.len is the length
     of the data available, so do whatever. */

    /* Write the content to stdout. */
    //write(STDOUT_FILENO, wdi.data, wdi.len);
    if(strlen(wdi.data) > CACHE_FIX_SIZE){
         printf("Page can never be cached for this cache size! Fetch from network.\n");
     }
     else {
      add_page(url.c_str(), wdi.data, strlen(wdi.data), CACHE_FIX_SIZE);
     }
    _return = string(wdi.data);
    free(wdi.data);
  }
  else {
    /* Write the content to stdout. */
    num_hits++;
    _return = ret_val;
    printf("\nPage found in cache. Returned from cache.\n");
  }
  print_hit();
  }

  static void print_hit()
  {
  hit_rate = num_hits/num_accesses;
  cout <<"Hit rate is: " << hit_rate << endl;
  cout << "number of hits " << num_hits << endl;
  cout << "number of num_accesses " << num_accesses << endl;
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<SomethingHandler> handler(new SomethingHandler());
  shared_ptr<TProcessor> processor(new SomethingProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}


